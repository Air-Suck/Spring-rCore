# 2024春夏季开源操作系统训练营总结报告

## 第一阶段总结报告

### 前言

作为一名大二在读生，在听同学说有一门语言很炫酷的时候，就算是面对着巨大的课业压力，我还是选择来看看rust到底是什么样的一门语言。

### Rustlings总结

刚刚接触rust语言时，我并没有意识到rust的强大之处，认为它只是一门新的语言罢了。但是当我跟着文档一步步去接触rust中全新的概念时，我才发现这门语言与其他的编程语言有多大的区别。

从rust变量的所有权与借用规则，再到后面的智能指针和生命周期，每一个特性都是那么晦涩难懂。我甚至在刚刚接触这些特性时，认为这些特性就是在束缚我，**让我没法自由自在的编程**。我甚至真的想过直接给我的所有rust代码套上一个unsafe。

但是没有束缚的自由也确实不是真正的自由。随着学校课程，尤其是操作系统课程的推进，让我知道了rust的所有权、借用规则以及智能指针，都是为了从语言层面提高整个计算机系统的性能，包括但不限于防止内存泄漏、不让指针乱飞、实现共享区互斥访问等。让我不用像写C语言一样，总是要考虑堆上变量有没有free，指针到底是几级指针，到底指的是什么玩意。不得不承认，经过rustlings110道练习的磨炼，我意识到，rust在通过它的特性，**让我更自由的编程**。

从头开始学习一门语言是不容易的，尤其是学习像rust这样特性贼多的语言。我在这里要感谢一位之前一直被我忽视的一位朋友——编译器。在之前编程时，不论是写C还是写Java，又或者是写Go，我总是认为编译器只不过是在检查我的语句是不是合法罢了。但是在写rust时，我就深深感受到，没有rust编译器，单单靠我一团浆糊的脑子和厚厚的文档，我是学不会rust的，甚至说都难以写出符合rust语法的程序。每次的报错都让我能够更深地了解rust的语言特性，每次的help，都能让我精确无误的修改错误。编译器好像一直在对我说：“嘿，跟着哥，哥带你学rust。”

希望我能够在接下来的阶段乃至之后与rust同行的时间里，跟着rust编译器，不断加深对rust的理解。

嘿，把rust当做母语真的很酷好吗。

## 第二阶段总结报告

### 前言

进入到第二阶段的同时，学校其实也开始进入了期末考试的阶段，每天我说的最多的一句话就是：汗流浃背了。但是好在，我还是走完了这一艰难但是有意义的阶段。

### 1-2 应用程序基本执行环境与批处理系统

虽然第一章和第二章并没有让我动手实践，但是看着文档一步步从搭建最小环境，再到实现自己的print，再到实现riscv特权级的切换。很难想象这是我在两章里面能学到的东西。

### 3 多道程序与分时多任务

从这里开始，我终于能上手碰碰操作系统了。

这个实验主要是要让我通过rust实现一个任务状态查询的系统调用。我最自然的想法是，任务状态一定是跟任务绑定的，所以我直接在TCB中新增了一个计算系统调用的成员变量。实现下来也是非常自然顺畅的。但是我知道这个方法应该不是最好的方法，毕竟要在TCB中创建一个挺大的数组，而TCB是属于操作系统内核的，并且操作系统中可能有许多的任务，这样就会导致操作系统内核比较臃肿。

### 4 地址空间

这一章就涉及到了我之前很少接触到的部分——虚拟地址空间。

从sv39多级页表机制到内核与应用的地址空间，这些内容都挺让我头大的。虽然在进入第四章时走了点弯路，编写代码的时候甚至没有涉及到逻辑段。当后来发现其实框架代码中有一些函数接口可以直接调用（如：shrink_to、append_to、insert_framed_area等），我就开始吐槽之前浪费了太多的时间。但是现在想想，这一段小插曲让我对虚拟地址空间有了更深的了解：从分配物理页帧，到建立虚拟地址和物理地址之间的映射，再到用户程序逻辑段的构建。艰难但有意义。

### 5 进程及进程管理

本章主要实现操作系统中一个重要的系统调用——spawn。此外还涉及到了一种调度算法——stride调度算法

spawn与fork+exec的最大的区别就是，spawn并不需要像fork一样完全复制父进程的地址空间，并依此再创建一个TCB，然后再通过exec将TCB重写为需要执行的用户程序的TCB。它是直接根据新的用户程序创建一个TCB，省去了重写TCB的开销。所以如果要实现一个spawn系统调用，就只需要模仿fork来实现就好了。

而stride调度算法就是在TCB中增加两个成员stride和priority，在不考虑性能的情况下，只需要遍历就绪队列并执行 stride最小的任务即可。但是受于双端队列的限制，就只能从队列中取出一个TCB然后进行比较，如果stride比当前已经选出的TCBstride还大的话就重新将其放回就绪队列，这样可行，但是会导致更大的系统开销。

#### 一些注意点

- 由于系统终止一个进程的时候是根据TCB的Arc指针强引用数量来判断的，所以很多地方就不能让编译器帮我drop变量，而是需要进行显式的变量drop。

### 6 文件系统与I/O重定向

在这一章的实验中我对操作系统中的另一个重要部分——文件系统有了基本的认识

从最底层的块设备、缓存，再到上层的文件系统以及操作系统相关的系统调用，学习下来我的感觉就是——多且杂，搞不明白为什么要分这么多层。但是现在回想一下这一切都是有意义的，这些分层让文件系统的不同层的代码高度解耦合，提高了文件系统的可移植性。

实验要求实现建立硬链接、释放硬链接以及查询文件状态系统调用。对于建立硬链接，我就按照文档上的提示按部就班为相同的磁盘索引块再创建了一个目录项。但是对于释放硬链接需要考虑的东西就多了：当一个文件在释放当前硬链接之后还存在硬链接的话，就只需要将磁盘上的某个目录项删除；当一个文件在释放当前硬链接之后没有硬链接了，那就需要将其在磁盘上所有的空间回收（虽然有同学说就算没有回收也能过测试用例）。而对于查询文件状态，我就是将需要查询的字段作为成员放在磁盘索引节点中，这样就能实现就算系统断电，文件的状态也不会丢失（由于是存储在磁盘块上而不是在内存中）

#### 一些注意点

- 删除目录项的时候按道理来说不能仅仅是将该目录项清零，而是应该将后面的目录项移动到前面来，并且如果移动后刚好空出了一个磁盘块，还需要去回收该磁盘块。但是在我的代码中仅仅实现到了将后面的目录项移动到前面，之后有时间可以尝试去改进一下。
- 在给磁盘索引节点增加成员的时候一定要减少直接索引的数量以保证一个磁盘块的大小是128字节。

### 7-8 进程间通信与并发

这两章的实验主要实现了一个重要的算法——死锁检测算法

这个算法其实在学校的课程中学过，是一个非常类似于银行家算法的算法，但是银行家算法是为了避免死锁。

这个算法中我觉得最让我摸不着头脑的就是need矩阵到底应该如何初始化。Available矩阵可以根据剩余的信号量或者锁是否被占用来实现；Allocation可以根据查询当前哪些线程在占据资源来确定。而need呢？显然不能单从信号量和锁的阻塞队列来确定。

从结果来看，其实应该是我的理解错了，我将死锁检测算法和银行家算法混淆了。我之前一直以为死锁检测算法中的need是一个线程在**全局角度**上对资源的需求量。而实际上need矩阵只是系统在**当前状态**下各个线程对资源的需求量，在每次需要分配资源时都需要调用死锁检测算法。所以死锁检测算法中的need矩阵是由信号量或者锁的阻塞队列以及当前请求资源的线程决定的。接下来只需要按照算法描述进行编码问题就迎刃而解了。

虽然第三阶段的时间与学校期末考试的时间完美重合，但是从第二阶段的学习中我真正感受到了操作系统的魅力，冲就完了

## 第三阶段总结报告

没想到为期40天的第三阶段这么快就结束了。现在回想一下这四十天几乎每天都在准备考试和参加训练营两个任务之间时间片轮转。但是很庆幸我还是走到了训练营的尾声。

在第三阶段的项目六：基于协程异步机制的操作系统/驱动中，我了解到了我之前只是略有耳闻的**异步**，收获到了很多新知识。

首先我先阅读了《200行代码讲透RUST FUTURES》。在这里我又接触到了许多的新概念：绿色线程、Future、执行器、唤醒器。。。现在回想，看的过程实在是非常折磨，不仅要重新回顾本就不扎实的Rust语法，还要把多线程多协程带来的混乱执行流捋清楚。但是当我把它看完了之后，我才豁然开朗，我才明白Executor、Waker、Reactor、Future是如何协同工作以提高计算机的使用效率的。这为我后续阅读Embassy以及完成最终的成果打下了坚实的理论基础。

在《200行代码讲透RUST FUTURES》提供的理论知识的加持下，我进一步阅读了《Embassy Book》。当回到我最熟悉的领域时，总是让人心旷神怡。在阅读《Embassy Book》的全过程中，我并没有遇到太多的障碍（可能这就是专业对口的优势吧），但是我却无时无刻不在感叹Embassy作者对Rust语言的了解程度、他对丑陋的硬件近乎完美的封装以及Embassy向用户提供的友好接口。这让我觉得Embassy好像并不是一个嵌入式运行时库，而更像是一个开销更低的操作系统。

接下来就到了我觉得很有意义的部分。在这一小阶段，我对Embassy源码进行了逐步的调试，尝试理解Embassy的执行流。在Embassy中，有许多宏。Embassy的作者通过这些宏能够暴露给使用者干净、高效的接口，但是这对于我这种初学Rust，并且想理解Embassy执行流的人而言无疑是令人厌烦的。因为它隐藏了太多协程的细节（Rust语法对我而言也是很大的问题），所以我只能从头开始对Embassy源码进行调试。通过调试工具的帮助，我揭开了Embassy神秘的面纱：从创建执行器，到创建协程池；从创建主任务，到协程的不断循环执行。在此时我才真正领悟了Embassy的强大之处。

终于到了coding部分。我与我的队友一起分工合作，成功使用Rust重构了uC/OS II的线程调度模块，并在uC/OS II的线程支持下应用了Embassy的协程机制。这使得Embassy的执行器对MCU不在是独占的，而是可以基于线程的调度算法进行轮转。并且在线程的支持下实现协程，进一步提高了我们的系统的并发度。而且有了线程的调度机制，我们也可以实现不同线程的协程在任意点切换。

现在回想我在阶段三中完成的任务我才发现这些内容是多么地有意义。我了解到了Rust中的协程的实现机制，也了解到了Rust协程的一个实际应用——Embassy，最终我基于这些理论知识成功将Rust的协程使用起来，让我基本了解了一个能有效提高计算机系统性能的“秘籍“。

三阶段固然有意义，但是如果没有他人的帮助，我绝对坚持不到现在。

首先需要感谢我的队友。从三阶段一开始，我们就一直在交流关于Rust Future的各种细节。而到了调试Embassy的部分以及后面的coding，我们也都紧密配合。在调试Embassy的部分，如果没有他的学习成果，我很有可能就会被Embassy高级的Rust语法劝退；在coding部分，如果没有我们共同的努力，我们肯定不会在这么短的时间内使用一个我们都不熟悉的Rust重构一个操作系统的灵魂——线程调度模块，并且在这个基础上使用Embassy的协程机制。

最后还需要感谢向勇老师。在向勇老师的悉心指导下，我和我的队友明确了我们将来的目标。我们希望在堆栈池的支持下，实现线程内部的协程抢占。并且在这个基础上进一步完善我们在阶段三产出的阶段性成果，并将其应用在我们的四轴飞行器中。

再次回顾我的阶段三全过程，虽然我做事情不多，但是我仍收获颇丰。我相信不紧不慢依旧能走向未来。希望我今后也能保持着对异步、对Rust、对OS的满腔热爱，笃行不辍，履践致远。

