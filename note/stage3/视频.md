# 视频

## 并发与处理器、操作系统和编程语言

向勇：[并发与处理器、操作系统和编程语言](https://www.xuetangx.com/learn/THU0809100czxt/THU0809100czxt/14294493/video/25500376)

### CPU硬件对并发的支持

- 中断是否需要硬件的支持？：中断**需要**CPU硬件的支持（最好是直接使用硬件支持），因为硬件当一条指令结束之后就会检查有没有中断，有中断的话再跳转。虽然这个方式与软件轮询相似（就是在每一条指令执行结束之后轮询中断是否发生），但是硬件直接实现的话就只需要加上一小块的电路，但是如果要软件实现的话不仅是代码量上的问题，更是程序规模、程序执行效率，操作系统的实时性等方面的问题。

  下图就是正常的机器执行的时候的流程：

  ![image-20240607114120404](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607114120404.png)

  实际上也是计组里面讲的指令的执行时间表，就是当前指令执行结束之后再进入中断周期，没有中断再进入普通的指令周期。

- 在RISC-V中的中断流程也是像上面这样的

- 用户态中断：在编译的时候，编译器为我生成了一个信号（signal）的处理例程，这个例程的效果就是当我kill的时候，**操作系统**就会去kill相应的进程。而用户态中断就是希望把这件事挪到用户态，让用户程序执行异常的时候（比如死循环啥的），当按下kill的时候，是用户程序本身跳转到某一个例程去执行（通过用户态中断的实现）来解决当前用户程序执行异常的问题，而**不是交给操作系统来做**（这样就能减轻操作系统的开销了。或者说是给一个用户程序发请求，而不是对操作系统和硬件发送中断，这样就能极大简化操作系统内部的处理signal相关的部分）。

  如果要给用户程序发送中断的话，就涉及到中断要发给谁，中断发送的目标进程可能处于睡眠状态、操作系统特权级这些问题，所以**不是简单地把内核或者硬件的中断搬到用户态来**

  ![image-20240607115653826](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607115653826.png)

  这里就能看出来用户态中断对性能的提升

  在实现上，这里有两张表，一个是发送方的表，指明了应该发送给谁；一个是收方的表，指明了能接收谁的发送，这样就建立起来了中断和用户进程的对应关系。当然这**两张表都需要在操作系统内核中**（这里就相当于是在给用户进程**注册中断**了），中断分发的相关机制还是要由操作系统来完成（毕竟可能当前用户程序可能已经无法正常运行了）。但是相较于传统的中断，这个还是有很大的提升。因为就算是直接将中断发送给操作系统内核的话，这个时候虽然不会涉及到中断的分发，但是会涉及到各种上下文的切换；但是如果使用用户态中断的话，就会使得操作系统只是在做分发的工作，剩余的事情都是交给用户进程进行处理的，所以总体上来看，操作系统的开销还是变小了

### 操作系统对并发的支持

- 内核天然是一个事件响应的机制（内核要响应所有用户态的系统调用事件），如下图：

  ![image-20240607121142664](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607121142664.png)

  这里有一个理解我觉得挺有意思的：当用户进程发送了一个系统调用请求的时候，用户进程就被停止了，这个时候内核**开始执行**（所以内核相当于是在响应系统调用）。然后内核会就这一个系统调用进行相应的检查，然后再去执行相关的操作。所以系统调用本质上就是一个**操作的安全性检查**，如果操作是安全的，那么内核才会通过自己的权限来执行用户态的相关请求；反之则不会执行（所以要区分特权级，就相当于是为了更好地进行安全性检查了。因为如果区分了特权级的话，用户态就没办法去随心所欲的操作计算机的所有资源，当涉及到一些计算机级别的资源的时候，用户就必须经过操作系统的检查才能使用）

- 硬中断的相应过程

  ![image-20240607121728259](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607121728259.png)

- 操作系统的中断响应过程

  ![image-20240607121757115](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607121757115.png)

- 信号（signal）：计网实验上面也有信号

  信号本质上是一个用户态的异常处理机制（计网实验上就是这样的，那个网络服务器就是在用户态的，他就能去相应发方，或者说是客户端发送的异常）

  ![image-20240607122043084](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607122043084.png)

  硬件中断会导致程序进入内核，并且在每一条指令执行结束之后都会硬件检查的；而用户态中断就是在从内核返回的时候检查当前进程是否有相关的用户态中断要响应，如果有的话就在当前进程的堆栈中附带上用户态中断的信息（所以分发还是操作系统进行的，但是操作系统中并不实际负责signal的处理，而是将signal的处理交给用户态来执行），然后当进程返回的时候是先处理向用户进程发送的异常

  执行过程如下：

  ![image-20240607150656807](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607150656807.png)

  就是返回的时候不会先返回到用户态的系统调用上，而是会先执行用户态中断，然后再执行原来的程序流（跟中断的表现是一样的）

- 用户态中断存在的意义：有的异常（或者说是突发事件）如何处理是由用户程序决定的，而不是内核以一种固定的形式进行处理

- 信号的响应时机

  - 发送信号并没有产生硬中断（也就是由内核和系统处理的中断），只是把信号挂载在目标进程的信号pending队列
  - 只在从内核到用户态该进程的时候才会检查该用户进程的pending队列，然后对其中的异常在用户进程的地址空间中进行处理（所以用户态中断的相应的时效性会差一点）

- 用户态中断与硬中断的区别

  - 响应时机：硬中断在每一次指令执行结束之后都会检查当前是否有硬中断；而用户态中断只会在系统从内核到用户的时候检查当前的用户进程是否有异常需要相应

- 用户级线程：就像在用户态实现了一个操作系统，也就是用户线程库，这样就不会出现线程切换的时候进入内核了。但是如果这样做的话，会导致如果一个线程出现故障，那么其他的线程由于没有自己的线程空间，就会导致其他线程也受到不同程度的影响（更直白的说，用户级线程对操作系统是不可见的，操作系统可能只是分配了一个内核级线程去执行这一堆用户级线程，这样就会导致如果一个用户级线程崩溃，那么对应的内核级线程也会崩溃，进而导致所有的用户级线程都会崩溃）

- 内核级线程：此时如果一个线程出问题了，那么其他的线程不会出现问题（因为此时每一个内核级线程都是相互独立的，都是操作系统可见的，在内核中都有这自己独立的空间）

- 线程与协程的实现：

  - 内核线程：由内核实现
  - 用户线程：用户库实现、语言支持
  - 协程：用户库实现、语言支持

- 线程与协程的切换

  - 中断上下文保存于恢复：基于中断
  - 进程切换：基于时钟中断、或者主动让权
  - 线程切换：基于时钟中断，或者主动让权
  - 协程切换：只能主动让权

- 异常和错误处理

  - 内核中断机制：硬件与操作系统协作，也就是硬中断是由操作系统和硬件共同解决的
  - 用户态中断：硬件、操作系统、**应用**协作管理

### Rust语言对并发的支持

- fut

  ![image-20240607152322330](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607152322330.png)

  下面的两个就是**异步**。这个时候就是用**信号**的机制完成**异步**的机制

- fut的概念

  - 执行器：执行机构——轮询（调用poll。如果当前没有能够执行的fut的话，执行器线程就会sleep）
  - 反应器：事件源（真正负责执行所有的叶子fut。当叶子执行结束了之后会设置叶子fut的状态，并且通过waker唤醒执行器）
  - 唤醒器：用于绑定事件和例程之间的关系（也就是异步事件和当前的程序流的关系）

- fut的状态转换

  ![image-20240607153209739](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607153209739.png)

  从这里可以看出，实际上rust的异步**跟操作系统并不直接相关**，而是一个用户态的库

### 异步操作系统

- 进程：有独立的地址空间，存有页表，切换开销大

  - 在异步操作系统中，内核是一个独立的进程，有自己的页表
  - 系统调用的过程会变成一种特殊和优化的线程切换（相当于是从用户进程切换到了内核进程）
  - 进程切换代码是在所有进程的内核态共享的（上下文切换代码在内核中写死了，是所有进程进行切换的时候都必须执行的）

- 线程：有独立的**堆栈**（但是地址空间是相同的），切换时需要保存和恢复全部的寄存器（所以还是有上下文切换的成本，但是由于不涉及到地址空间切换等操作，所以开销会比进程切换小）

  - 由于内核与用户线程不在一个地址空间中，每一个用户线程只有用户栈（是因为内核看不见用户级线程，进而就没办法给每一个用户线程分配栈空间了，所以用户线程的栈只能是用户线程自己在自己的用户空间中创建一个用户栈，而没有内核栈）
  - 每个内核级线程只有内核栈，不存在对应的用户栈（？跟学校的操作系统课上讲的不一样**疑问**）

- 协程： 可以理解为状态机的转移函数，执行时可共用一个栈（由于所有的协程都是共用一个栈的，所以被称为**无栈协程**）

  - 每个线程内可以有多个协程
  - 编译器讲async函数变换为状态机时，函数中需要跨越await的变量将存放在状态机的状态对象中（由编译器生成，并且状态机一般是存储在堆上的），其他变量只需要放在栈上或者寄存器中（因为不需要跨await，所以当前部分的代码段执行结束之后就可以丢弃了）

- 理想的协程切换——跨线程，甚至跨进程的协程调度

  - 当同一进程中主动让权协程间的切换，此时由于是主动的，所以协程切换的时候会将当前跨await点的变量都保存在堆上，所以这个时候是无栈的切换（因为栈中没有有效信息），所以就是**协程切换**
  - 当同一进程中由于被抢占让权协程间的切换。由于此时相当于是被中断打断了，那么此时就会导致栈中还是有当前协程执行的信息（也就是当前协程还没有来得及将自己的运行信息保存在堆上），这个时候就涉及到了**栈的切换**（协程是没有栈的，只有线程是有栈的），所以这个时候就是一个**线程切换**
  - 不同进程中由于被抢占让权协程间的切换。已经是不同进程间的了，这个时候就肯定涉及到了进程的切换

- 理想的异步系统调用

  - 用户态的异步系统调用会执行编译器自动生成相应的系统调用请求代码，维护协程控制块数据结构

  - 在第一次系统调用请求时和最后一次系统调用完成时，会从用户态进入内核态（现在的rCore是**每一次**系统调用都会陷入到内核态）

  - 中间的各次系统调用只进行系统调用的**请求提交**和**结果查询**，并进行进程线程或者协程的切换（这个意思就是，当我发出一次系统调用之后，用户进程不会再被停止然后陷入到内核，而是会将系统调用的请求直接发送给内核进程，然后由**内核进程**处理之后再返回结果。而用户进程在这一段时间仍然是在向后执行的。说白了就是——**将系统调用做成了一个异步事件**。但是如果要做到内核进程一直在运行，并且用户进程也在运行的话，就最少需要两个CPU核，如下图）。

    ![image-20240607162558210](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240607162558210.png)

    这个时候就是两个CPU上的用户进程和内核进程就是**异步**的了，因为左边的CPU上运行的用户进程只是发送了一个系统调用请求，然后就**继续执行**（没有可执行的就被挂起），并没有陷入到内核态；而右边的CPU上运行的内核进程就只是负责去监听系统调用请求，然后处理系统调用，最后向左边的用户进程返回结果

    这个机制一般是通过**请求队列**和**响应队列**进行的。然后当系统调用结束之后，可能是通过**类似fut的机制**，返回给用户一个fut，然后当这个fut执行结束之后，给用户进程发送一个**用户态中断**，让用户进程知道该系统调用已经结束了

  - 在当前协程的系统调用还没有结果返回且没有新的可执行用户任务时，才会执行协程切换（也就是系统调用这个异步事件还没有返回，并且当前协程已经没有办法继续poll的时候，才会进行线程切换） 

- 共享调度器：用户运行和内核相同的调度代码（也就是**调度器由用户和内核共享**）