# 环境配置

今天是5.22。一直以为第三阶段是在六月份才开始的，所以这两天一直在赶学校的作业，一直没有碰第三阶段。。。

在正式进入第三阶段前，我打算先配置一下虚拟机的远程连接，因为VMware实在是太卡了，但是环境都配置在上面又不得不使用虚拟机，就只能尝试一下同学建议的远程连接了

主要参考：[vscode远程连接](https://blog.csdn.net/qq_29856169/article/details/115489702)

主要步骤如下：

- vscode 安装Remote-Developoment并配置
- Linux 安装 OpenSSH-Server 并配置
- 编写 vscode 的 ssh 配置文件

里面有一条指令我觉得很有意思：

```shell
sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup # 备份
```

竟然可以直接使用cp命令生成备份文件

## 坑点

- 博主说的Remote-SSH版本其实没有问题，可能之后修复了

- 出现Failed to find a non-Windows SSH installed只需要按照提示的要去去关闭相应的配置即可。打开打开“文件->首选项->设置"，然后取消勾选下面的选项即可

  ![img](https://img-blog.csdnimg.cn/20200422192153207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NzI3MTQ3,size_16,color_FFFFFF,t_70)

- 安装结束之后还有一个很麻烦的地方就是每次远程连接都要去输密码。只要在虚拟机上的~/.ssh/authorized_keys文件中添加Windows的ssh公钥即可实现免密登录。

## 注意点

- ```shell
  type %USERPROFILE%\.ssh\id_rsa.pub
  ```

  这个指令可以查看ssh密钥。

  之前对ssh密钥的理解也不太深入。这个密钥看样子是和机器绑定的。所以如果将本机的ssh公钥放在github上，那么使用ssh进行clone的时候就会去检查github上已有的密钥是否与本机ssh密钥匹配。匹配成功了才会允许进行clone

- 关于rust-analyzer，他是通过识别当前工作区下面的Cargo.toml文件来提供rsut的语言分析的，所以如果出现当前工作区的toml文件并没有在rust-analyzer的工作区中，就会出现无法分析的情况

## Embassy book中的环境配置

到这里我就想起来，我的日志是没办法输出到PC终端上的，并且还不支持图形化调试

- **图形化调试**：实际上就是使用cortex debug+jlink来搞，之前已经搞过了，主要就是安装一下cortex-debug，装一下Jlink驱动然后再写一个launch.json文件就好了

  安装插件没什么好说的，直接安装就好了

  Jlink驱动的安装：[JLink驱动](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/) 

  这个网站实际上是STLiink转JLink固件的教程，但是里面也有安装JLink驱动的部分，所以就摆这个链接了

  接下来就是json文件的编写，之前也写过了：

  ```json
  {
      // 使用 IntelliSense 了解相关属性。 
      // 悬停以查看现有属性的描述。
      // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
          {
              "name": "J-Link Cortex-M4 Debug",
              "type": "cortex-debug",
              "request": "launch",
              "servertype": "jlink",
              "cwd": "${workspaceRoot}",
              "executable": "${workspaceRoot}/examples/stm32f4/target/thumbv7em-none-eabi/release/blinky",
              "device": "STM32F401RE",
              "interface": "swd",
              "svdFile": "${workspaceRoot}/examples/stm32f4/STM32F401.svd",
              "runToEntryPoint": "main",
              // 添加这一行以使用gdb-multiarch
              "gdbPath": "/usr/bin/gdb-multiarch"
          }
      ]
  }
  ```

  主要就是指定文件路径，gdb啥的，没啥好说的

- **日志输出**：如果正常使用JLink的话好像就没办法输出日志信息了。。。

  因为刚好defmt是使用RTT协议的，而JLink又支持RTT（不然SystemView怎么可能能用，所以感觉还是能使用JLink的

  从JLink支持SystemView来看，可以发现JLink是不需要做任何的配置的，他默认就是打开了RTT端口的，不然SystemView也办法获取这些RTT数据。另一方面可以发现应该是SystemView做了对RTT数据的处理。所以按道理来说如果没有使用defmt的话，直接在终端中拉一个JLinkRTTClient起来是能看见信息的，但是由于使用了defmt，导致JLinkRTTClient没办法解析这些数据了。所以这里就需要使用defmt print，而不能使用JLinkRTTClient。但是最少知道JLink调试的时候就已经打开了rtt，，并且端口号是localhost:19021（因为拉JLinkGDB的时候就能使用JLinkRTTClient链接上了）。那么按道理来说只需要使用defmt-print链接19021端口就能获取这些defmt信息了。

  但是安装defmt坑点还是比较多的，不能使用cargo add，也不能直接在Cargo.toml中直接加defmt-print依赖。下面是参考了这个教程，使用cargo install来安装的：[安装defmt-print](https://lib.rs/install/defmt-print)。这样在编译项目的时候就不会出现问题了
  
  之后发现可能是因为没有启动rtt服务的问题。今天继续配置
  
  cortex-debug支持RTT：
  
  ![image-20240609110649109](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240609110649109.png)
  
  发现使用JLinkRTTClinet是能接收到数据的，但是输出是乱码。说明是defmt-print的问题。但是如果直接使用cargo add安装的话又会出现编译不通过的问题。
  
  这里就只能手动安装这个依赖了。这里没办法把这个玩意当成是项目的依赖，那我就只好直接手动编译然后配到环境变量里面了。
  
  在手动编译的过程中也能看见一些print需要的依赖：
  
  ![image-20240609132113237](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240609132113237.png)
  
  果然直接把defmt-print配成环境变量就好了，md，完全没必要把这个玩意作为项目的依赖来搞。终于搞定了

